---
editor: source
---

# Good coding practices

In the last chapters, you have learned how to name your names and variables and how to set up a decent project structure.
In this chapter, you will learn good coding practices to help other researchers and future you with the code you used for your analysis.

## Respective R projects

As a researcher (and as a student) you work on different projects simultaneously.
You have different research projects and teaching parts that you need to cover in your job.
You attend different courses and do presentations and data analyses in these seminars and lectures.
As you have learned in the previous chapter about project structure, it makes sense to set up your files and folders in a particular research project folder.

```
|projects
|--version-control-book
|--reproducibility-book
|--grant_neuroscience_horizon
|--grant_neuroscience_dfg
```

We highly recommend to use specific R-projects for each project, respectively.
This will become clear throughout this chapter and the next chapter about `renv`.

To create an R-project, follow these steps:

1. Open RStudio
1. Click on the blue {{< fa cube >}} cube with a R in it and a green plus {{< fa circle-plus >}} on the outside.
1. Decide whether you want to create a new directory or an existing directory.

::: panel-tabset
## New Directory

Click on **New Directory**, then **New Project** and type in your directory name. 
Make sure that your project is at the correct place in your folder system.
At this time point, it does not matter whether you want to create a *git repository* and/or use *renv* with this project.
In the future chapters you will learn the advantages of using git and renv.

When you click on **Create project**, your R project will be created.
You will see that R created a folder named after your directory and that one file `directory-name.Rproj` is in this folder.

## Existing Directory

Click on **Existing Directory** and make sure which folder you want to turn into an R-project.

When you click on **Create project**, your R-project will be created. You will see that R put a file in your chosen folder called `directory-name.Rproj`.
:::

Depending on your situation it makes sense to either create a new directory or turn an existing folder into an R-project.
When you are at the beginning of your project and have not set up a project structure yet, it makes sense to create a new directory.
Make sure, that in this case, your directory name aligns well with your project.
When you have alrady set up a project structure, it makes sense to turn your project folder into an R-project. Make sure that in this case your project folder is the folder you turn into an R-project.

::: callout-tip
## What is an `.Rproj`-file?

The `.Rproj`-file contains the settings for all files related to your specific R project.
It is automatically created when you create an R-project. By double-clicking on the file, you open the project in RStudio. It is not recommended to change this file manually.
:::

After you have created your R project it is time to take a deep look into your R-scripts containing the code for your projects.

## Comments

Comments are probably the most important part of your scripts.
Whenever you write a `#` in your R-script, all code after that `#` will be identified as comment and therefore not be executed as code.
Thus, if you put a `#` at the beginning of a line, the whole line will be identified as comment.
Here are some thoughts about comments by Nicola Rennie:

::: callout-note
## Adding comments

- Add comments using a `#` in R (in a separate line)
- Comments don`t need to explain *what* your code does
- Comments should explain *why* you did it
:::

You can use `#` not only for comments but also for creating sections and subsections in your R-script.
To do so, you must start a line with at least one has `#` and put at least 4 hyphens after your comment.
The number of hashes you use at the beginning determines the level of section.

```{r}
# Section 1 ----

## Subsection 1.1 ----

## Sebsection 1.2 ----

# Section 2 ----
```

## Absolute and relative file paths

All of the time when you are doing research, you have to conduct your analysis on some sort of data.
This data is usually stored in one or more files.
Thus, you have to read the data into your script.
TO do so, you need to refer to the files you want to read.
Here comes a first advantage of setting up a particular R-project for your research project.

You can read data or code into your R-environment by referring to your data through absolute paths and relative paths.

### Absolute file paths

Using an absolute path means that you refer to your file name by going through your whole computer folder structure:

```{r}
#| eval: false
data <- read_csv("/Users/my-user-name/document/projects/my-project/data/data-raw.csv")
```

Using absolute file paths is not recommended in terms of computational reproducibility.
A collaborator or interested researcher who downloaded your scripts and want to reproduce your analysis has to change these paths before the scripts can run correctly.

```{r}
#| eval: false
data <- read_csv("/Users/user-name-b/desktop/work/research/my-project/data/data-raw.csv")
```

### Relative file paths

A relative file path takes the path from your current *working directory* and puts it before your relative path.
You can check your current working directory in R by using the `getwd()` command.

```{zsh, filename="check working directory"}
getwd()
[1] "Users/my-user-name/my-project"
```

By default, the working directory in an R project is the project folder, in the example called `my-project`.

You can then use the relative file path from that folder to read your data.
You can use the file path that starts *after* the working directory:

```{r}
#| eval: false
data <- read_csv("data/data-raw.csv")
```

Thus, all relative paths to the files in an R-project remain the same insensitive to the person who wants to work with that project.

## Code Style {#sec-codestyle}

One important aspect that fosters understandability of code is the code style.
To make this more clear, let's think of an example.
Consider yourself in a research project where you want to examine the robustness of the finding that women show higher neuroticism values than men.
You have found a lot of papers examining this relationship, usually finding that indeed women show higher values than men.
Now you are sitting in front of a paper from Wittkuhn et al. (2024).
You want to check if the convenient finding of the authors is due to an error in the code of actually correct.
Compare the following two examples of code.
Which one would you prefer when you want to rerun analyses and why?

```{r}
#| label: bad-code-example
#| eval: FALSE
#| code-line-numbers: true

library(package=tidyverse)
library(psych)#load packages
#get data
DATA<-bfi
#get means of neuroticism-items by gender
DATA$N <- rowMeans(DATA[16:20], na.rm=TRUE)
describeBy(DATA$N, DATA$gender)

#Result: women have higher neuroticism values then men (descriptively)
t.test(N ~gender, data, alternative= "l")#confirmation
#Plot Result in Boxplot
DATA$gender <- factor(DATA$gender, levels= c(1,2), labels =c("male","female"))
ggplot(DATA)+
  geom_boxplot(aes(gender, N, group = gender, fill = gender),show.legend = F)+
  scale_fill_manual(values = c("lightblue", "pink"))
#Done
```

```{r}
#| label: good-code-example
#| eval: false
#| code-line-numbers: true

## Investigating the relationship of neuroticism and gender ##
## Hypothesis: Women show higher values on a neuroticism-scale than men ##

# load required packages
library(psych) #for statistical computations, also contains data
library(tidyverse) #for data wrangling and visualization

# get dataset
data <- bfi #Big Five Inventory

# familiarize with dataset
str(data)
head(data)
print(bfi.dictionary) #getting itemformulations
?bfi #more background information about the data

# create scale variable that contains the means of all N-items of each person
data$N <- rowMeans(
  data[16:20], #select corresponding Neuroticism-Items
  na.rm=TRUE #remove missing values
  )

# get labels for gender values
print(bfi.dictionary) #males = 1, females = 2
data$gender <- factor(
  data$gender,
  levels = c(1, 2),
  labels = c("male", "female")
)

# check correct labels
str(data$gender)

# get descriptive differences
describeBy(
  x = data$N,
  group = data$gender #group values by gender
)
      # Result:
        # Males:    M = 2.95, SD = 1.14
        # Females:  M = 3.27, SD = 1.21
      # Descriptive Statistics congruent to hypothesis.

# check for significant differences
t.test(
  N ~ gender,
  data = data,
  alternative = "less" #assume that men show lower values than women
)
      # Result: Women show significantly higher values in neuroticism-scale than men. 
        # t = 6.727, p < .001
      # Significance testing also congruent to hypothesis

# plot results as a boxplot
ggplot(
  data = data,
  mapping = aes(
    x = gender,
    y = N
    )
  )+
  geom_boxplot(
    mapping = aes(
      group = gender, #two separate boxplots for each gender
      fill = gender #two separate colors for each gender
    ), 
    show.legend = FALSE
  )+
  scale_fill_manual( #set up different colors manually
    values = c(
      "lightblue",
      "pink"
    )
  )
```

## Tidy Data

As you might have noticed when you worked through the @sec-codestyle section, the dataset `bfi` was organized well.
That does not always hold true, when you work with datasets.
In fact, most of the time you are facing datasets, you will spend more time organizing your data than running real analysis.
A helpful concept is **tidy data**, which is a common guideline for datasets to be organized.
Following tidy data guidelines will help you running analyses and getting the most out of your data.

::: callout-important
## Tidy Data

Tidy datasets follow three basic rules:

1.  Each variable is a column; each column is a variable.
2.  Each observation is a row; each row is an observation.
3.  Each value is a cell; each cell is a value.
:::

![Visualization of Tidy Data by Wickham et al. ([2024](https://r4ds.hadley.nz/data-tidy)). Used under a [CC BY-NC-ND 3.0 US license](http://creativecommons.org/licenses/by-nc-nd/3.0/us/).](/images/tidy-1.png){fig-align="center"}

## Code Testing

## Acknowledgements & further reading

We would like to express our gratitude to the following resources, which have been essential in shaping this chapter.
We recommend these references for further reading:

| Resources |
|------------------------------------------------------------------------|
| Buhr, J. (2023). *Introduction to Data Analysis with R.* <https://jmbuhr.de/dataintro/> |
| Rennie, N. (2024). *Writing Better R Code.* <https://nrennie.rbind.io/training-better-r-code/> |
| Wickham, H., Çetinkaya-Rundel, M., & Grolemund, G. (2024). *R for Data Science (2e)*. <https://r4ds.hadley.nz> |