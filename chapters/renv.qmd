---
title: "Robust Environments: `{renv}`"
editor: source
engine: knitr
execute:
  eval: false
  warning: false
  message: false
code-annotations: hover
categories: [intermediate]
abstract: |
  In this chapter you will learn how your reproducible research project becomes robust against different package versions.
  You will make it easy for you to and collaborators to use the same package versions in your joint project.
---

## Introduction

Now a project is well-named including its files and folders.
It is well-structured and follows a community standard as Psych-DS.
It follows the FAIR principles.
The code is written in the tidyverse-style.
Is it reproducible?
Well, it may be.
Very likely, it is not.

Imagine you need to reproduce the results of a research article from 2019.
The project structure is openly available at [OSF](https://osf.io/) or at [Zenodo](https://zenodo.org/).
You find a nice structure, run a script but then you get an error message in R like:

```{zsh filename="Output"}
#| code-copy: false
Error in function_name(object[[i]], ...) : could not find function "function_name"
```

R is telling you that it cannot find a function called function_name.
A similar problem can be that only arguments of a function are not found.
However, the script runs correctly at the device of the researcher writing the script.
Thus, you are facing a research project that is only reproducible on the same device it was written for.
A possible reason is that your computational environment differs from the environment of the other researcher.
You might have installed different versions of R packages or of {{< fa brands r-project >}} itself.

::: {.callout-tip title="Computational environments" collapse="true"}

<!--# Introduction to computational environments if not done in a separate chapter -->

:::

Different computational environments can hinder computational reproducibility.
In the example above, the code cannot be executed.
However, sometimes package updates do only change the calculation of a function or an argument.
Thus, a different package version leads to **different results** even though the code runs correctly.

::: {.callout-important title="Problems of different computational environments"}

- scripts could stop running because of different functions or arguments
- scripts could run correctly but produce different results
:::

::: {.callout-tip title="How `renv` helps aligning computational environments"}

With `renv`...

- package versions can be safed inside a research project
- collaborators can easily load the same package versions independent of their device
- R projects become isolated, portable and reproducible [@ushey2024]
:::

<!--# What we will be able to do after this chapter -->

## `renv`

`renv` is a package that cares about the different versions of your used packages.
To use `renv` as package dependency manager, you only need to install it, as every other package.

```{zsh filename="Console"}
install.packages("renv")
```

::: {.callout-tip title="Benefits of `renv`"}
- easy documenting package versions
- easy restoring of older package versions
<!--# Is this callout-box redundant to the one above?-->
:::

### `renv`-functions

The `renv` package is very powerful because it does a lot of useful things while only needing 4 (+1) functions. 
Before we start, it is helpful to disentangle a couple of terms.
A **library** is a directory containing multiple packages.
This is confusing because you load packages with the command `library(package)`.
The command does not load a library, but a package.
Until now you install packages into your **System library** with `install.packages("package")` and load these packages within this library with `library(package)`.
Packages in the system library are independent from your project. 
With `renv`, we will start to use **project libraries**.
Thus, we will install and use packages to a library that meets the requirement for your specific projects.
However, it might occur that you have to install the same packages multiple times when you want to use them across multiple projects.

#### `renv::init`

When you start using renv, we recommend you to set up an R-project before.
If you do not know how to do that, see @sec-rproject.
With `renv::init()`, we initialize our project.
With this command, a couple of files and folders are created.

- `.Rprofile` is a file that automatically runs everytime you start your R-project.
Renv uses it to set up your project library.
Thus, once you have turned on your project library, it remains active until you turn it off.

- `renv/library` contains all the packages you are currently using.
This is now your project library.
With different libraries for different projects you have the benefit of *isolation*.
When a package version changes in one project, it does not affect your other projects.

- The lockfile `renv.lock` contains all the metadata of your packages to reinstall it on a new machine.
It serves as documentation about which package and which version of the packages you use.
It also displays the R version used in your particular project.

<details>
<summary>Click here to view the full `renv.lock` file of this project.</summary>
```{json, filename="renv.lock"}
#| file: renv.lock
#| code-line-numbers: true
```
</details>

#### `renv::install`

With `renv::install`, we can install new packages to our project.
Assume you need the package `palmerpenguins` in your project.

```{r filename="Console"}
#| echo: true
#| eval: false

renv::install("palmerpenguins")
```

`renv` will download the package `palmerpenguins`.
If you want to install packages with dependencies, renv will install these dependencies automatically.
In your console you will be asked if you want to install the package to your project library.
Type `Y` in to your console.

```{zsh filename="Output"}
#| code-copy: false
# Downloading packages -------------------------------------------------------
- Downloading palmerpenguins from CRAN ...      OK [2.9 Mb in 1.8s]
Successfully downloaded 1 package in 2.1 seconds.

The following package(s) will be installed:
- palmerpenguins [0.1.1]
These packages will be installed into "~/Documents/repro-book/renv/library/macos/R-4.4/aarch64-apple-darwin20".

Do you want to proceed? [Y/n]: 
```

After that, you should see something in your console similar to this:

```{zsh filename="Output"}
#| code-copy: false
# Installing packages --------------------------------------------------------
- Installing palmerpenguins ...                 OK [installed binary and cached in 0.34s]
Successfully installed 1 package in 0.42 seconds.
```

Now you have installed the package `palmerpenguins` to your project library.

::: {.callout-note title="What are dependencies?" collapse="true"}
Some packages require other packages to be loaded.
These other packages are called dependencies.
Your primary package depends on these other packages to run correctly.

The package `psychonetrics` has a lot of packages.
Install the package to see what happens.

```{r filename="Console"}
#| echo: true
#| eval: false

renv::install("psychonetrics")
```
:::

#### `renv::snapshot`

When you search in the lockfile for your new installed package `palmerpenguins`, you will not find it there.
renv does not automatically saves the metadata of your installed packages in the lockfile.
With `renv::snapshot()`, we can document the package versions we need in our project.
Simply run the command in your Console

```{r filename="Console"}
#| echo: true
#| eval: false

renv::snapshot()
```

In your Console, you will see something like this:

```{zsh, filename="Output"}
#| code-copy: false
- The lockfile is already up to date.
```

Renv did not add the metadata about palmerpenguins to the lockfile.
This is because renv checks if your package is really used somewhere in your project.
The bare installation is not enough.
This is to not unneccessarily overload the lockfile with packages that are not used in the project.
The package has to be used and therefore loaded somewhere in the project.
Create a script `test_palmerpenguins.R`, type `library(palmerpenguins)`, and save it in your project.
Then try the snapshot command again:

```{r filename="Console"}
#| echo: true
#| eval: false

renv::snapshot()
```

Your console should have an output like this:

```{zsh filename="Output"}
#| code-copy: false
The following package(s) will be updated in the lockfile:

# CRAN -----------------------------------------------
- palmerpenguins    [* -> 0.1.1]

Do you want to proceed? [Y/n]: 
```

Again, type `Y`.
Then, you should see an output like this:

```{zsh filename="Output"}
#| code-copy: false

- Lockfile written to "path/to/your/project/folder/renv.lock".
```

When you open the lockfile, you will find the metadata of palmerpenguins there.
`renv::snapshot()` is useful because you and your collaborators will be able to reconstruct your package versions. The reconstruction relies on the lockfile and `renv::snapshot()` will update your current packages used in your project.

#### `renv::restore`

With `renv::restore`, we can restore versions of our used packages.

#### `renv::status`

### `renv`-workflow

```{r}
#| results: asis
#| eval: true
#| echo: false
cat(make_figure("renv-workflow"))
```

<!--# Insert a figure of a renv-workflow -->

## References

somehow include:

- https://rstudio.github.io/renv/articles/renv.html
